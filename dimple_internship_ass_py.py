# -*- coding: utf-8 -*-
"""Dimple_internship_ass.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eFBsKs_EL-zmjV56fgJNgh_6YXWZ5eHz

Section 1 - Funnel Analysis

1.Import all the necessary library and Handle Missing
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error, mean_absolute_percentage_error

file_path = "AssignmentData.xlsx"
funnel_df = pd.read_excel(file_path, sheet_name="WorkerFunnel")
funnel_df.head(10)

# Check for missing values
missing_values = funnel_df.isnull().sum()
print("Missing Values:\n",missing_values)


# Remove rows with missing values (alternative)
funnel_df.dropna(inplace=True)

# Remove duplicate rows
funnel_df.drop_duplicates(inplace=True)
funnel_df.head()



"""2.Create a new column called Target Achieved (categorical as "Yes" if Actual Productivity is greater than Targeted Productivity, and "No" otherwise). Then, Complete the below given tasks using the columns : Department, Targeted Productivity, Overtime, Number of Workers, Quarter, and Start and End Dates of the observations in the dataset. And give a summary of the results."""

# Create 'Target Achieved' column
funnel_df['Target Achieved'] = np.where(funnel_df['Actual Productivity'] > funnel_df['Targeted Productivity'], 'Yes', 'No')

# Display the updated dataframe
funnel_df.head()

# Convert Date column to datetime format
funnel_df['Date'] = pd.to_datetime(funnel_df['Date'])

# Sort the dataframe by Date
funnel_df.sort_values('Date', inplace=True)

# Define a function to calculate MAPE and MSE
def evaluate_forecast(actual, forecast):
    mape = mean_absolute_percentage_error(actual, forecast)
    mse = mean_squared_error(actual, forecast)
    return mape, mse

# ARIMA Forecasting
arima_model = ARIMA(funnel_df['Actual Productivity'], order=(5,1,0))
arima_fit = arima_model.fit()
arima_forecast = arima_fit.forecast(steps=4)

# Rolling Averages Forecasting (adjusted to exclude NaN values)
rolling_avg_forecast = funnel_df['Actual Productivity'].rolling(window=4).mean().shift(-1)

# Evaluate Rolling Averages forecast (excluding NaN values)
rolling_avg_mape, rolling_avg_mse = evaluate_forecast(
    funnel_df['Actual Productivity'].tail().dropna(),
    rolling_avg_forecast.dropna().tail()
)

# Display the forecasts and evaluation metrics
print("\nRolling Averages Forecast (adjusted to exclude NaN values):")
print(rolling_avg_forecast.dropna().tail(3))
print("Rolling Averages MAPE:", rolling_avg_mape)
print("Rolling Averages MSE:", rolling_avg_mse)



"""Section 2 - A/B Testing

Import data from the ABTest sheet of the AssignmentData.xlsx file into a dataframe named abtest and perform exploratory analysis.

1. Create a timeseries visualization with Date (on x-axis) and Total Number of Clicks (on y-axis) for each device type creating separate trendlines for each device in order to find which device performed best in terms of total number of clicks.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import norm, binom_test
!pip install streamlit
import streamlit as st

# Load data from Excel file
file_path = "AssignmentData.xlsx"
abtest_df = pd.read_excel(file_path, sheet_name="ABTest")
abtest_df.head(5)

# Create a timeseries visualization for Total Number of Clicks by Device
plt.figure(figsize=(12, 6))
sns.lineplot(x='Date', y='Clicks', hue='Device', data=abtest_df, ci=None)
plt.title('Total Number of Clicks by Device Over Time')
plt.xlabel('Date')
plt.ylabel('Total Number of Clicks')
plt.legend(title='Device')
plt.show()

# Calculate Sample Size Required for the Test
def calculate_sample_size(mde, alpha, power, control_conversion_rate):
    z_alpha = norm.ppf(1 - alpha/2)
    z_beta = norm.ppf(power)
    p = control_conversion_rate
    q = 1 - p
    n = ((z_alpha * np.sqrt(2 * p * q) + z_beta * np.sqrt(p * (1 - p) + p * (1 - q)))**2) / (mde**2)
    return n

"""2. Assume MDE = 3%, α = 95% and statistical power (1-β) = 80%,. What is the sample size required for the test? (Use this article to supplement your understanding - Sample Size in A/B Testing). Do we have sufficient sample size to conclude the test?"""

# Calculate Sample Size Required for the Test
def calculate_sample_size(mde, alpha, power, control_conversion_rate):
    z_alpha = norm.ppf(1 - alpha/2)
    z_beta = norm.ppf(power)
    p = control_conversion_rate
    q = 1 - p
    n = ((z_alpha * np.sqrt(2 * p * q) + z_beta * np.sqrt(p * (1 - p) + p * (1 - q)))**2) / (mde**2)
    return n
mde = 0.03
alpha = 0.05
power = 0.8
control_conversion_rate = abtest_df['Clicks'].sum() /abtest_df['Visitors'].sum()

sample_size = calculate_sample_size(mde, alpha, power, control_conversion_rate)
print("Sample Size Required for the Test:", sample_size)

"""4. Write a function that accepts the following inputs to test your hypothesis at the chosen level of statistical significance:

Control Group Visitors
Control Group Conversions
Treatment Group Visitors
Treatment Group Conversions
Confidence Level (three options: 90, 95, 99).
The function should output one of 3 values - {"Experiment Group is Better", "Control Group is Better", "Indeterminate"}.
Use the function to perform AB Test on the given Data and provide your findings and interpretation of the results.

"""

# Hypothesis Testing Function
def ab_test(control_visitors, control_conversions, treatment_visitors, treatment_conversions, confidence_level=0.95):
    p_value = binom_test([control_conversions, treatment_conversions], [control_visitors, treatment_visitors])[1]
    alpha = 1 - confidence_level
    if p_value < alpha:
        return "Experiment Group is Better"
    elif p_value > alpha:
        return "Control Group is Better"
    else:
        return "Indeterminate"

# Calculate the total number of visitors and conversions for each group
control_group = abtest_df[abtest_df['Group'] == 'Control']
control_visitors = control_group['Visitors'].sum()
control_conversions = control_group['Clicks'].sum()

treatment_group = abtest_df[abtest_df['Group'] == 'Experiment']
treatment_visitors = treatment_group['Visitors'].sum()
treatment_conversions = treatment_group['Clicks'].sum()

from scipy.stats import binom_test

# Hypothesis Testing Function
def ab_test(control_visitors, control_conversions, treatment_visitors, treatment_conversions, confidence_level=0.95):
    p_value_control = binom_test(control_conversions, control_visitors)
    p_value_treatment = binom_test(treatment_conversions, treatment_visitors)
    alpha = 1 - confidence_level
    if p_value_treatment < alpha and p_value_treatment < p_value_control:
        return "Experiment Group is Better"
    elif p_value_control < alpha and p_value_control < p_value_treatment:
        return "Control Group is Better"
    else:
        return "Indeterminate"

# Perform AB Test
result = ab_test(control_visitors, control_conversions, treatment_visitors, treatment_conversions)
print("AB Test Result:", result)

"""4"""

